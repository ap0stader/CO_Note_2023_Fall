# P2课下-做题记录

## P2.Q1 P2_L0_matrix 题目编号 1121-37

### 源代码文件
- [P2_Q1.asm](https://gitee.com/ap0stader/CO_2023_Fall/blob/main/3_P2/MARS/P2_Q1.asm)

### 思考
这道题一是熟悉教程中二维数组内存操作的`.macro`写法，一是复习for循环的写汇编法。矩阵相乘的C语言写法，在大一程设时已经写过了（当时写的还是[矩阵的幂次mini](https://accoding.buaa.edu.cn/problem/6343/index)）。  
编写时以下几点需要留意：
1. `.space`后的数字的单位是Bytes，如果在C语言中使用了长度为100的int型数组，`.space`后需要为400。
2. 如果使用`lw`和`sw`指令，访问的地址必须是4的非负整数倍。在`.data`中应该先写`.space`，再写`.asciiz`。因为`.asciiz`不会对齐到4的整数倍。
3. for循环嵌套for循环时容易出现结构混乱、标签混乱、寄存器混乱等情况。像C语言一样，先把`for (int i = 0; i < n; ++i)`这一部分的结构写好，再去填充循环内的逻辑能有效避免最后再修改的麻烦。嵌套或复用时**框架**上更改**循环变量的寄存器4处**和**标签4处**。我的for循环模板：
    ```mipsasm
    # 先前步骤：
    # n <= $s0

    # for (int i = 0; i < n; ++i)
    # int i = 0
    li $s1, 0
    # for循环标签模板
    # for_(任务)_(循环变量名称)_begin/end
    for_input_i_begin:
        # i < n
        beq $s1, $s0, for_input_i_end

        # do something

        # ++i
        addiu $s1, $s1, 1
        j for_input_i_begin

    for_input_i_end:
    # do something
    ```

### C语言代码
- [Q1.c](./C/Q1.c)


## P2.Q2 P2_L0_judge 题目编号 1121-34

### 源代码文件
- [P2_Q2_1.asm](https://gitee.com/ap0stader/CO_2023_Fall/blob/main/3_P2/MARS/P2_Q2_1.asm) : $v0 = 12版本
- [P2_Q2_2.asm](https://gitee.com/ap0stader/CO_2023_Fall/blob/main/3_P2/MARS/P2_Q2_2.asm) : $v0 = 8版本

### 思考
这道题是熟悉MARS中读取字符的Syscall的特性（题目中有测评机与MARS表现不同的相关说明）。
1. 使用`li $v0, 5`读取数字，会“吃”掉行尾的换行符。这与`scanf("%d", &n)`不同。故在C语言中，在`scanf("%d", &n)`后应该用`getchar()`“吃”掉行尾的换行符再循环调用`fgets()`，否则第一次只读取换行符。
2. MARS的帮助文档中说明`li $v0, 8`与`fgets()`行为相同。如果`li $a0, 1`，不会有内容写入到内存中。如果`li $a0, 2`，将会一次读取字母，一次读取换行符。如果`li $a0, 3`，那么将一次性读取一个字母加换行符。因为只关心字母，下一读取时写入的内存地址只需+1，覆盖掉换行符即可。

### C语言代码
- [Q2.c](./C/Q2.c)


## P2.Q3 P2_L0_conv 题目编号 1121-281

### 源代码文件
- [P2_Q3.asm](https://gitee.com/ap0stader/CO_2023_Fall/blob/main/3_P2/MARS/P2_Q3.asm)

### 思考
P2.Q1的加强版，嵌套循环4层。编写时应十分注意标签的修改和寄存器与循环变量的对应关系。

### C语言代码
- [Q3.c](./C/Q3.c)


## P2.Q4 P2_L0_full_1 题目编号 1121-36

### 源代码文件
- [P2_Q4.asm](https://gitee.com/ap0stader/CO_2023_Fall/blob/main/3_P2/MARS/P2_Q4.asm)

### 思考
这道题是复习递归函数的写法。全排列的C语言写法，在大一程设时已经编写过了（[重炮的数学时间](https://accoding.buaa.edu.cn/problem/6020/index)）。  
1. 和一般函数调用一样，应在开头和返回前对`$ra`和`$s`类的值进行保存和恢复。
2. **要格外注意对于`$a`类和`$t`类寄存器的值的保存和恢复**。一般函数调用时这些寄存器大都不做保护，但是递归时因为执行相同的指令，这些寄存器的值一定会被改变。若这些值在递归后还需要使用，一定要对其进行保存和恢复。

### C语言代码
- [Q4.c](./C/Q4.c)

### 问题
1. 翻译C语言的时候漏翻译了一个对于中间变量的操作，导致WA了一次。


## P2.附加题1 P2_L1_puzzle 题目编号 1121-38

### 源代码文件
- [P2_puzzle.asm](https://gitee.com/ap0stader/CO_2023_Fall/blob/main/3_P2/MARS/P2_puzzle.asm)

### 思考
1. 题目提示使用深度优先搜索。比较简单的实现方式是“图数组 + 是否已经访问的标记数组”的数据结构以及“出发 -> 判断是否可行已经是否已经访问 -> 递归调用四个方向”的算法。
2. 为了使算法逻辑更加简单，在整个图的四个边加上了一圈表示不可以走的1，这样就不用判断这个值是否是边界值从而决定是否不向某个方向递归。实现的方法是先将一个(n + 2) * (m + 2)置1，然后再把数据输入到中间的n * m的区域中。
3. 由于在内存中二维数组是线性存储的，故在进行顺序访问时不必写两个for循环以及计算地址的`.macro`。使用一个for循环，从起始地址循环到终止地址即可。如：按照上一点读取输入的图，同一行内的两个数字循环变量加4，换到下一行第一个数字循环变量加12，从0循环到`(n * m) << 2`即可。
4. 题目中要求了*每组数据最多执行5,000,000条指令*，似乎需要一些高效的算法和优化，但是测试数据应该比较友善，基础的递归算法也能通过。~~变态的测试数据例如6 x 6的迷宫，全为0，从(1,1)到(6,6)，有1262816种走法。~~
5. ~~[accoding上与这题相同的一道古老的题目](https://accoding.buaa.edu.cn/problem/178/index)~~

### C语言代码
- [A1.c](./C/A1.c)

### 问题
1. 入栈时先延长栈，再写入数据。出栈时先读取数据，再缩短栈。先进栈的后出栈。第一次编写时，写了两处错误的代码，导致了程序运行表现混乱。
    ```mipsasm
    .macro pop (%dst)
        addiu $sp, $sp, 4
        lw %dst, ($sp)
    .end_macro
    ```
    ```mipsasm
    push($a0)
    push($a1)
    # do something
    pop($a0)
    pop($a1)
    ```


## P2.附加题2 P2_L1_factorial 题目编号 1121-418

### 源代码文件
- [P2_factorial_tle.asm](https://gitee.com/ap0stader/CO_2023_Fall/blob/main/3_P2/MARS/P2_factorial_tle.asm) : TLE版本
- [P2_factorial_o1.asm](https://gitee.com/ap0stader/CO_2023_Fall/blob/main/3_P2/MARS/P2_factorial_o1.asm) : 优化第一版
- [P2_factorial_o2.asm](https://gitee.com/ap0stader/CO_2023_Fall/blob/main/3_P2/MARS/P2_factorial_o2.asm) : 优化第二版
- [P2_factorial_o3.asm](https://gitee.com/ap0stader/CO_2023_Fall/blob/main/3_P2/MARS/P2_factorial_o3.asm) : 优化第三版

### 思考
本题的基础是高精度乘法。高精度乘法的C语言写法，在大一程设时已经编写过了[求求你了帮帮可莉吧！](https://accoding.buaa.edu.cn/problem/6386/index)。比较简单的实现方法是从1循环到输入给定的数值，每一轮都与之前的结果进行高精度乘法。题目中保证***输出字符串长度小于等于1000***，即不会计算大于449的阶乘。第一版C语言代码如下
```C
#include <stdio.h>
#define N 1000
int result[N];
int main() {
    int n;
    scanf("%d", &n);
    result[0] = 1;
    for (int i = 2; i <= n; i++) {
        int in = 0;
        for (int j = 0; j < N; j++) {
            int temp_result = result[j] * i + in;
            result[j] = temp_result % 10;
            in = temp_result / 10;
        }
    }
    int top_number = 0;
    for (int i = N - 1; i >= 0; i--) {
        if (result[i] != 0) {
            top_number = i;
            break;
        }
    }
    for (int i = top_number; i >= 0; i--) {
        printf("%d", result[i]);
    }
}
```

### 优化
在MARS中，可以通过菜单栏中`Tools`->`Instruction Counter`或`Instruction Statistics`查看运行的指令数和不同类型的指令的分布情况。使用前点击`Connect to MIPS`。该计数器在复位之后的值不会清零会继续累加，需要手动点击`Reset`重置计数器。
题目中要求***步数限制为200,000***，若直接按照上述代码翻译，将会获得**TLE**。  
1. TLE -> O1（已经能AC）: **限长**  
    TLE版之所以步数特别多，主要来源于`for (int j = 0; j < N; j++)`，每一次循环时都要对1000个位做乘法。但是实际上很多时候都是在作没有意义的乘0。故设一变量保存当前最高位的数组的下标。这个值在已经乘到了最高位，但是进位仍不为0的情况+1，循环直到进位为0。
    ```C
     int size = 0;
     for (int i = 2; i <= n; i++) {
         int in = 0;
         for (int j = 0; j <= size; j++) {
             int temp_result = result[j] * i + in;
             result[j] = temp_result % 10;
             in = temp_result / 10;
             if (j == size && in > 0) {
                 size++;
             }
         }
     }
    ```
    优化之后，因为测试数据也比较友善，已经能够AC了。TLE版本计算82位的60!需要832552步，O1版本只需要29295步。能在要求步数内计算完的值达到了242位的140!
    但是

2. O1 -> O2 : **压位**  
    虽然已经AC了，但是受到了<http://cscore.buaa.edu.cn/#/discussion_area/1027/1158/posts>的启发，故继续在O1版上进行优化。  
    O1版中虽然已经限制了每次计算的位数，但是计算机并不是只能计算1位乘3位的乘法的。如果每个int单元都保存多位数字，在做乘法时就能一次性对多位进行乘法，保存的位数越多，能减少额计算步数就越多。由题目的限制可知，不会计算超过449的阶乘，而  
        `999999 x 449 = 44899951 < 2147483647`  
        `9999999 x 449 = 4489999551 > 2147483647`  
    故为了保证计算安全，每个int单元保存6位数字。只需要长度为167的int数组
    ```C
    int result[167];

    int size = 0;
    for (int i = 2; i <= n; i++) {
        int in = 0;
        for (int j = 0; j <= size; j++) {
            int temp_result = result[j] * i + in;
            result[j] = temp_result % 1000000;
            in = temp_result / 1000000;
            if (j == size && in > 0) {
                size++;
            }
        }
    }
    ```
    每个int单元保存6位数字，但可能高位为0，故输出时应该补0到6位。
    ```C
    printf("%06d", result[i]);
    ```
    汇编中可以通过连续的判断以及输出实现`%06d`的效果
    ```mipsasm
    bge $t0, 1000, output
	$v0 -> $a0 -> syscall
    bge $t0, 100, output
	$v0 -> $a0 -> syscall
    ......
    ```
    优化之后，O1版本需要198291步计算的242位的140，在O2版本只需要35451步。能在要求步数内计算完的值达到了637位的309!

3. O2 -> O3 : **调指令**  
    距离题目给定的最大值1000位还有距离，还可以在什么地方进行优化呢？


    
    虽然距离题目给定的最大值1000位还有距离，输出部分虽然还可再优化，但本身的步数就只有千余步，优化的意义不大。每一条指令都已经是压着MIPS指令集设计的规范，个人分析也没有重复的判断和运算。在不修改算法的情况下，已经基本达到了我的极限了。  
    忽然想起《庄子》中写道“吾生也有涯，而知也无涯。以有涯随无涯，殆已！”，这一次的优化就到这里吧。

总结：
1. 各版本对比
    | 版本 | 计算60!的步数 |
    | :--: | :-----------: |
    | TLE  |    832552     |
    |  O1  |     29295     |
    |  O2  |     5878      |
    |  O3  |     4879      |

2. O3版优化结果
    | 计算数字 | 结果位数 |  步数  |
    | :------: | :------: | :----: |
    |   60!    |    82    |  4879  |
    |   334!   |   700    | 198906 |
    |   335!   |   703    | 200215 |
    |   449!   |   999    | 380022 |

### 问题
1. 忘记了`.space`后的数字的单位是Bytes，`int result[1000]`翻译成了`result: .space 1000`，虽然并不会导致程序的运行出现异常，但是者本身就是个错误。
