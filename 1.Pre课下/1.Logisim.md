# 2023秋计算机组成

## Pre课下-Logisim

**Logisim 参考手册**
http://www.cburch.com/logisim/docs/2.7/en/html/libs/index.html

### Logisim门电路

#### Tunnel
每个Tunnel标签只允许有一个输入，输出的数量不做限制。  
不建议使用太多的Tunnel，防止出现混乱，而且输入Tunnel的标签非常浪费时间，有时候也很清晰。

#### Probe
使用Probe进行监控任意导线上传输的内容，无需管位宽。  
使用Poke Tool进行点击同样可以进行查看。

#### 全加器的表达式 
>    S = A ^ B ^ Cin;  
> Cout = A & B | Cin & (A ^ B);

#### 九个不太常见的组件
- Gate
  1. Odd Parity (2k+1) : 奇校验门，输入中有**奇数个1**时输出为1，否则输入为0。
  2. Even Parity (2k) : 偶校验门，输入中有**偶数个1（含0个）**时输出为1，否则输出为0。
  3. Controlled Buffer : 三态缓冲器。控制端为1时，输出值与输入值相同。控制端为0时，输出值为浮空值x。
  4. Controlled Inverter : 三态反相器。控制端为1时，输出值为输入值取反。控制端为0时，输出值为浮空值x。
- Plexers
  1. Priority Encoder (Pri) : 编码器，Decoder的逆向组件，左侧从上到下从0开始编号。控制端为1时，若输入端存在1，则输出最大编号的1所在的编号的二进制数，同时输出信号1。若控制端为0，或者控制端为1但输入端没有1时，则输出端为全浮空值x，同时输出信号0.
- Arithmetic
  1. Negator (-x): 取反码器。注取反码的计算规则为各位取反再加1，0b10000000的反码仍然是0b10000000，不会出现溢出的情况
  2. Bit Adder (#) : 按位加法，输出为输入当中有多少个1的二进制数。
- Memory
  1. Shift Register : 移位寄存器。始终上升沿来临时，前一个寄存器存储后一个寄存器的值，最后一个寄存器存储输入的值。提供一个使能端，一个异步清零端。提供一个初始化控制端和初始化数据输入端，当初始化控制端为1前时钟上升沿来临时，各寄存器保存初始化数据输入的值。提供各个寄存器当前保存值的输出端口，最后一个阶段的输出端口额外多提供一个。
  2. Random Generator : 随机数生成器，可以指定种子。提供一个使能端和一个清除端，当清除端为1时，**异步**将输出恢复到种子

#### 自己的研究
1. [bit_extender.circ](./1.Logisim/1.Logisim门电路/bit_extender.circ) : Bit Extender的在同配置下的拓展的结果演示
2. [splitter.circ](./1.Logisim/1.Logisim门电路/splitter.circ) : Wiring -> Splitter元件的各种样式以及分信号、集信号两个方向的使用
3. [tunnel_and_probe.circ](./1.Logisim/1.Logisim门电路/tunnel_and_probe.circ) : Tunnel和Probe两个工具的使用演示
4. [xor.circ](./1.Logisim/1.Logisim门电路/xor.circ) : 使用与门和或门构建基础异或电路

### 题目1109-12 搭建swap电路
  
#### 源代码文件
- [question_1109_12_1.circ](https://gitee.com/ap0stader/CO_2023_Fall/blob/main/0_Pre/logisim/question_1109_12_1.circ) : 使用普通连线版本
- [question_1109_12_2.circ](https://gitee.com/ap0stader/CO_2023_Fall/blob/main/0_Pre/logisim/question_1109_12_2.circ) : 使用Tunnel版本

#### 表达式
> O1 = ~S & I1 | S & I2  
> O2 = S & I1 | ~S & I2

从题目要求中的*请从门级电路开始搭建，切勿使用Plexers类元件*的要求中可以看出这道题目与`Plexers`类元件有着密切的联系。上面的两个表达式是多路选择器(Multiplexer)的表达式，其中S是选择位(Select bits)，O1和O2是这两个`Multiplexer`的输出结果，I1和I2按照不同的次序接入到`Multiplexer`中。  
搭建swap电路，实际上实现了两路的`Multiplexer`。多路选择器还可以继续扩展，从更多的路中选择想要的路作为输出。

#### 多路选择器表达式模板
以一个四路的`Multiplexer`为例，其**表达式**如下
> O = (~S1 & ~S0) & I00  
>   | (~S1 &  S0) & I01  
>   | ( S1 & ~S0) & I10  
>   | ( S1 &  S0) & I11

**真值表**如下
| S1  | S0  |  O  |
| :-: | :-: | :-: |
|  0  |  0  | I00 |
|  0  |  1  | I01 |
|  1  |  0  | I10 |
|  1  |  1  | I11 |

为了表达所有可以选择的路，首先需要更多的`Select bits`，一般情况下（包括logisim中），使用**二进制编码**方式按照次序给输入的各路进行编号。  
上面的表达式为用**或**逻辑链接的4个式子，其中每个式子表达的是输入的选择位为某种情况时对应的输出。每个式子的用括号括住的前半部分表达的是何时被选中。后半部分表达的是这种情况下对应的输出。  
前半部分的构造方法为用`&`来连接各个`Select bits`，在被选中的情况的编码中，`Select bits`为0时应加上～。这样构造出来的前半部分当且仅当在被选中的情况下为真，其余情况的构造出来的前半部分均为假，搭配上`|`即可实现多路选择。

需要特别的指出的是，如果输入为**多位**的，应先将括号中的结果的`&`应该**符号**位拓展后再与输入按位与，`|`也应为按位或

> 更多内容可以参见黑书P47-P50 2.8.1节 复用器

### Logisim组合电路

#### Splitter
每一个端口输出哪些位可以在属性窗口指定。不一定是**连续**的位，但是输出的时候是按照大小顺序依次输出。  
<center><img decoding="async" src="../Image/1/001.png" width="75%"></center>
<center><img decoding="async" src="../Image/1/002.png" width="75%"></center>

#### Splitter相关题目测试文件  
1. [question_1109_571.circ](./1.Logisim/2.Logisim组合电路/question_1109_571.circ)  
2. [question_1109_572.circ](./1.Logisim/2.Logisim组合电路/question_1109_572.circ)

#### Plexers题目测试文件
1. [question_1109_573.circ](./1.Logisim/2.Logisim组合电路/question_1109_573.circ) : MUX和Decd  
2. [question_1109_574.circ](./1.Logisim/2.Logisim组合电路/question_1109_574.circ) : MUX和DMX
3. [question_1109_575.circ](./1.Logisim/2.Logisim组合电路/question_1109_575.circ) : 逻辑左移位器
<center><img decoding="async" src="../Image/1/003.png" width="75%"></center>

#### 什么时候引入子电路？
1. 设计的电路中存在完全重复的部分
2. 完全重复的部分有明确的**独立功能**定义
3. 完全重复的部分有明确的**输入输出**定义
   
#### 引入子电路注意事项！
1. 要检查外观编辑页面，确定模块的每个输入输出端口在模块内部对应的端口，在外观上应该对于每个端口应该有所标注。
2. 子电路的外观默认是一样的，应在外观上标明子电路的功能。

#### 自己的研究
1. [smg_decoder.circ](./1.Logisim/2.Logisim组合电路/smg_decoder.circ) : 使用组合逻辑构建的0-9的数码管译码器，输入二进制数，得到对应的数码管的显示的编码
  ![smg_decoder.png](./1.Logisim/2.Logisim组合电路/smg_decoder.png "smg_decoder.png")

### Logisim时序电路
  
#### 自己的研究
1. [init_circuit.circ](./1.Logisim/3.Logisim时序电路/init_circuit.circ) : 两种初始化电路的书写方式
    1. 使用 Comparator->Bit Extender->AND Gate->OR Gate
    2. 使用 D Flip-Flop(+Constant)->Multiplexer
2. [latch.circ](./1.Logisim/3.Logisim时序电路/latch.circ) : 从门级搭建锁存器和寄存器，并且演示**异步电路**的竞争条件会导致的问题（黑书P68）
3. [mealy.circ](./1.Logisim/3.Logisim时序电路/mealy.circ) : Mealy型状态机示例以及与Moore型状态机的对比（黑书P78）
4. [memory.circ](./1.Logisim/3.Logisim时序电路/memory.circ) : 题目1109-585的测试文件，演示memory中的RAM元件的使用
5. [moore.circ](./1.Logisim/3.Logisim时序电路/moore.circ) : Moore型状态机实例（黑书P73）
  